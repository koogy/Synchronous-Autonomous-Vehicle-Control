open Globals
open Utilities
type st = St_Turn|St_TrafficLight|St_Obstacle|St_Go|St_Arrived|St_Action
const obstacleDistance = 70
const dt = 0.016000
node convertMsToDps(ms : float) returns (rpm : float)
var v : float;
let
  rpm = (v *. 6.000000);
  v =
    ((60.000000 /. ((2.000000 *. Globals.pi) *. (Globals.cD /. 2.000000))) *.
     ms)
tel

node power2(value1 : int) returns (v : int)
let
  v = (value1 * value1)
tel

node compare_colors(color1 : Globals.color; color2 : Globals.color)
returns (v : float)
var v_8 : int; v_9 : int; v_10 : float; v_11 : int; v_12 : int; v_13 : float;
    v_14 : float; v_15 : int; v_16 : int; v_17 : float; v_18 : float;
let
  v = Mathext.sqrt(v_18);
  v_18 = (v_14 +. v_17);
  v_17 = Mathext.float(v_16);
  v_16 = power2(v_15);
  v_15 = (color1.Globals.blue - color2.Globals.blue);
  v_14 = (v_10 +. v_13);
  v_13 = Mathext.float(v_12);
  v_12 = power2(v_11);
  v_11 = (color1.Globals.green - color2.Globals.green);
  v_10 = Mathext.float(v_9);
  v_9 = power2(v_8);
  v_8 = (color1.Globals.red - color2.Globals.red)
tel

node getDirection(left : float; mid : float; right : float; action : float)
returns (direction : int)
var min : float; v : float; v_19 : float; v_20 : bool; v_21 : bool;
    v_22 : bool; v_23 : int; v_24 : int;
let
  direction = if v_20 then 1 else v_24;
  v_24 = if v_21 then 0 else v_23;
  v_23 = if v_22 then ~-(1) else 0;
  v_22 = (min = right);
  v_21 = (min = mid);
  v_20 = (min = left);
  min = Utilities.min_float(v, v_19);
  v_19 = Utilities.min_float(action, right);
  v = Utilities.min_float(left, mid)
tel

node getTimeAngle(deg : float; ms : float) returns (time : float)
var arcLength : float; circumference : float; v : float; v_25 : float;
    v_26 : float; v_27 : float;
let
  time = (v_26 /. v_27);
  v_27 = (ms /. 100.000000);
  v_26 = (arcLength /. 100.000000);
  arcLength = (v_25 *. circumference);
  v_25 = (v /. 360.000000);
  v = Utilities.abs(deg);
  circumference = (Globals.pi *. Globals.cB)
tel

node calculateK(kc : float; pc : float)
returns (kp : float; ki : float; kd : float)
var v : float; v_28 : float; v_29 : float;
let
  kd = (v_29 /. (8.000000 *. dt));
  v_29 = (kp *. pc);
  ki = (v_28 /. pc);
  v_28 = (v *. dt);
  v = (2.000000 *. kp);
  kp = (0.600000 *. kc)
tel

node setSpeed(turn : float; tp : float) returns (rspeed : Globals.wheels)
var right : float; left : float; v : float; v_30 : float; v_31 : float;
    v_32 : float; v_33 : float; v_34 : float;
let
  rspeed = { Globals.left = left; Globals.right = right };
  right = Utilities.max_float(v_33, v_34);
  v_34 = ~-.(tp);
  v_33 = Utilities.min_float(v_32, tp);
  v_32 = (tp -. turn);
  left = Utilities.max_float(v_30, v_31);
  v_31 = ~-.(tp);
  v_30 = Utilities.min_float(v, tp);
  v = (tp +. turn)
tel

node isAction(c : Globals.color) returns (res : bool)
var v : float;
let
  res = (v = 1.000000);
  v = Utilities.compare_colors(c, Globals.green)
tel

node dbg_float(msg : string; v : float) returns 
var w2 : Debug.world; w1 : Debug.world; w0 : Debug.world; v_35 : Debug.world;
let
  w2 = Debug.d_string(w1, "\n");
  w1 = Debug.d_float(w0, v);
  w0 = Debug.d_string(v_35, msg);
  v_35 = Debug.d_init()
tel

node controller(sens : Globals.sensors; iti : Globals.itielts)
returns (rspeed : Globals.wheels; arriving : bool)
var tp : float; lastActionTime : float; actionIndex : int; time : float;
    compt : int; actionIndex_1 : int; lastActionTime_1 : float; tp_2 : float;
    pnr : bool; nr : bool; r : bool; ns : st; v_36 : int; v_37 : int;
    v_38 : float; ck : st; rspeed_St_Action : Globals.wheels;
    arriving_St_Action : bool; actionIndex_St_Action : int;
    lastActionTime_St_Action : float; tp_St_Action : float;
    ns_St_Action : st; nr_St_Action : bool; rspeed_St_Go : Globals.wheels;
    arriving_St_Go : bool; actionIndex_St_Go : int;
    lastActionTime_St_Go : float; tp_St_Go : float; ns_St_Go : st;
    nr_St_Go : bool; rspeed_St_Obstacle : Globals.wheels;
    arriving_St_Obstacle : bool; actionIndex_St_Obstacle : int;
    lastActionTime_St_Obstacle : float; tp_St_Obstacle : float;
    ns_St_Obstacle : st; nr_St_Obstacle : bool;
    rspeed_St_Turn : Globals.wheels; arriving_St_Turn : bool;
    actionIndex_St_Turn : int; lastActionTime_St_Turn : float;
    tp_St_Turn : float; ns_St_Turn : st; nr_St_Turn : bool;
    rspeed_St_TrafficLight : Globals.wheels; arriving_St_TrafficLight : bool;
    actionIndex_St_TrafficLight : int;
    lastActionTime_St_TrafficLight : float; tp_St_TrafficLight : float;
    ns_St_TrafficLight : st; nr_St_TrafficLight : bool;
    rspeed_St_Arrived : Globals.wheels; arriving_St_Arrived : bool;
    actionIndex_St_Arrived : int; lastActionTime_St_Arrived : float;
    tp_St_Arrived : float; ns_St_Arrived : st; nr_St_Arrived : bool;
    act : Globals.action; v_99 : bool; v_100 : bool; v_101 : bool;
    v_102 : st; v_103 : bool; v_104 : st; v_105 : bool;
    v_106 : Globals.itielt; derivative : float; integral : float;
    error : float; lastError : float; kd : float; ki : float; kp : float;
    turn : float; right : float; mid : float; left : float;
    isObstacle : bool; tLight : bool; actionMark : bool; error_1 : float;
    integral_1 : float; derivative_1 : float; v_64 : st; v_65 : bool;
    v_66 : st; v_67 : bool; v_68 : float; v_69 : float; v_70 : float;
    v_71 : bool; v_72 : float; v_73 : int; v_74 : float; v_75 : float;
    v_76 : bool; v_77 : float; v_78 : float; v_79 : bool; v_80 : float;
    v_81 : float; v_82 : float; v_83 : float; v_84 : float;
    v_85 : Globals.itielt; v_86 : bool; v_87 : float; v_88 : bool;
    v_89 : bool; v_90 : float; v_91 : bool; v_92 : float; v_93 : bool;
    v_94 : bool; v_95 : bool; v_96 : float; v_97 : float; v_98 : float;
    v_63 : bool; speed : float; turn_time : float; cpt : int;
    v_46 : Globals.itielt; v_47 : int; v_48 : Globals.itielt; v_49 : float;
    v_50 : bool; v_51 : int; v_52 : int; v_53 : int; v_54 : float;
    v_55 : int; v_56 : Globals.itielt; v_57 : Globals.itielt; v_58 : bool;
    v_59 : float; v_60 : Globals.wheels; v_61 : float; v_62 : Globals.wheels;
    v_39 : float; v_40 : bool; v_41 : bool; v_42 : float; v_43 : bool;
    v_44 : bool; v_45 : bool;
let
  tp_2 = 0.000000 fby tp;
  lastActionTime_1 = 0.000000 fby lastActionTime;
  actionIndex_1 = ~-(1) fby actionIndex;
  r = pnr;
  pnr = false fby nr;
  ck = St_Action fby ns;
  tp_St_Action = (tp_2 when St_Action(ck));
  act = v_106.Globals.act;
  v_106 = (iti when St_Action(ck))[>(actionIndex when St_Action(ck))<];
  actionIndex_St_Action = ((actionIndex_1 when St_Action(ck)) + 1);
  arriving_St_Action = false;
  rspeed_St_Action = Globals.idlew;
  lastActionTime_St_Action = (time when St_Action(ck));
  nr_St_Action = if v_99 then true else v_105;
  ns_St_Action = if v_99 then St_Turn else v_104;
  v_105 = if v_100 then true else v_103;
  v_104 = if v_100 then St_Go else v_102;
  v_103 = if v_101 then true else false;
  v_102 = if v_101 then St_Arrived else St_Action;
  v_101 = (act = Globals.Stop);
  v_100 = (act = Globals.Go);
  v_99 = (act = Globals.Turn);
  derivative_1 = if (r when St_Go(ck)) then 0.000000 else v_98;
  v_98 = 0.000000 fby derivative;
  integral_1 = if (r when St_Go(ck)) then 0.000000 else v_97;
  v_97 = 0.000000 fby integral;
  error_1 = if (r when St_Go(ck)) then 0.000000 else v_96;
  v_96 = 0.000000 fby error;
  lastActionTime_St_Go = (lastActionTime_1 when St_Go(ck));
  actionIndex_St_Go = (actionIndex_1 when St_Go(ck));
  arriving_St_Go = false;
  () = dbg_float("TIME 1 ", (time when St_Go(ck)));
  isObstacle = if v_95 then true else false;
  v_95 = ((sens when St_Go(ck)).Globals.s_sonar <= obstacleDistance);
  tLight = if v_94 then true else false;
  v_94 = (v_91 or v_93);
  v_93 = (v_92 >=. 1.000000);
  v_92 =
    Utilities.compare_colors
    ((sens when St_Go(ck)).Globals.s_front, Globals.amber);
  v_91 = (v_90 >=. 1.000000);
  v_90 =
    Utilities.compare_colors
    ((sens when St_Go(ck)).Globals.s_front, Globals.red);
  actionMark = if v_89 then true else false;
  v_89 = (v_86 & v_88);
  v_88 = (v_87 >. 0.500000);
  v_87 = ((time when St_Go(ck)) -. (lastActionTime when St_Go(ck)));
  v_86 = isAction((sens when St_Go(ck)).Globals.s_road);
  rspeed_St_Go = setSpeed(turn, (tp when St_Go(ck)));
  tp_St_Go = convertMsToDps(v_85.Globals.param);
  v_85 = (iti when St_Go(ck))[>(actionIndex when St_Go(ck))<];
  turn = (v_83 +. v_84);
  v_84 = (kd *. derivative);
  v_83 = (v_81 +. v_82);
  v_82 = (ki *. integral);
  v_81 = (kp *. error);
  lastError = error_1;
  derivative = if v_79 then derivative_1 else v_80;
  v_80 = (error -. lastError);
  v_79 = isAction((sens when St_Go(ck)).Globals.s_road);
  integral = if v_76 then integral_1 else v_78;
  v_78 = (v_77 +. error);
  v_77 = ((2.000000 /. 3.000000) *. integral_1);
  v_76 = isAction((sens when St_Go(ck)).Globals.s_road);
  error = if v_71 then error_1 else v_75;
  v_75 = (mid *. v_74);
  v_74 = Mathext.float(v_73);
  v_73 = getDirection(left, mid, right, v_72);
  v_72 = compare_colors((sens when St_Go(ck)).Globals.s_road, Globals.red);
  v_71 = isAction((sens when St_Go(ck)).Globals.s_road);
  right = v_70;
  mid = v_69;
  left = v_68;
  v_70 =
    compare_colors((sens when St_Go(ck)).Globals.s_road, Globals.magenta);
  v_69 = compare_colors((sens when St_Go(ck)).Globals.s_road, Globals.blue);
  v_68 = compare_colors((sens when St_Go(ck)).Globals.s_road, Globals.cyan);
  (kp, ki, kd) = calculateK(0.700000, 2.360000);
  nr_St_Go = if actionMark then true else v_67;
  ns_St_Go = if actionMark then St_Action else v_66;
  v_67 = if tLight then true else v_65;
  v_66 = if tLight then St_TrafficLight else v_64;
  v_65 = if isObstacle then true else false;
  v_64 = if isObstacle then St_Obstacle else St_Go;
  tp_St_Obstacle = (tp_2 when St_Obstacle(ck));
  lastActionTime_St_Obstacle = (lastActionTime_1 when St_Obstacle(ck));
  actionIndex_St_Obstacle = (actionIndex_1 when St_Obstacle(ck));
  arriving_St_Obstacle = false;
  rspeed_St_Obstacle = Globals.idlew;
  nr_St_Obstacle = if v_63 then true else false;
  ns_St_Obstacle = if v_63 then St_Go else St_Obstacle;
  v_63 = ((sens when St_Obstacle(ck)).Globals.s_sonar > obstacleDistance);
  tp_St_Turn = (tp_2 when St_Turn(ck));
  lastActionTime_St_Turn = (lastActionTime_1 when St_Turn(ck));
  actionIndex_St_Turn = (actionIndex_1 when St_Turn(ck));
  arriving_St_Turn = false;
  rspeed_St_Turn = if v_58 then v_60 else v_62;
  v_62 = { Globals.left = speed; Globals.right = v_61 };
  v_61 = ~-.(speed);
  v_60 = { Globals.left = v_59; Globals.right = speed };
  v_59 = ~-.(speed);
  v_58 = (v_57.Globals.param >. 0.000000);
  v_57 = (iti when St_Turn(ck))[>(actionIndex when St_Turn(ck))<];
  speed = convertMsToDps(v_56.Globals.param);
  v_56 = (iti when St_Turn(ck))[>v_55<];
  v_55 = ((actionIndex when St_Turn(ck)) - 1);
  turn_time = (Globals.timestep *. v_54);
  v_54 = Mathext.float(cpt);
  cpt = (v_51 + v_53);
  v_53 = if (r when St_Turn(ck)) then 0 else v_52;
  v_52 = 0 fby cpt;
  v_51 = if true then 1 else 0;
  nr_St_Turn = if v_50 then true else false;
  ns_St_Turn = if v_50 then St_Action else St_Turn;
  v_50 = (turn_time >. v_49);
  v_49 = getTimeAngle(v_46.Globals.param, v_48.Globals.param);
  v_48 = (iti when St_Turn(ck))[>v_47<];
  v_47 = ((actionIndex when St_Turn(ck)) - 1);
  v_46 = (iti when St_Turn(ck))[>(actionIndex when St_Turn(ck))<];
  tp_St_TrafficLight = (tp_2 when St_TrafficLight(ck));
  lastActionTime_St_TrafficLight =
    (lastActionTime_1 when St_TrafficLight(ck));
  actionIndex_St_TrafficLight = (actionIndex_1 when St_TrafficLight(ck));
  arriving_St_TrafficLight = false;
  rspeed_St_TrafficLight = Globals.idlew;
  nr_St_TrafficLight = if v_45 then true else false;
  ns_St_TrafficLight = if v_45 then St_Go else St_TrafficLight;
  v_45 = (v_41 & v_44);
  v_44 = not(v_43);
  v_43 = (v_42 = 1.000000);
  v_42 =
    Utilities.compare_colors
    ((sens when St_TrafficLight(ck)).Globals.s_front, Globals.amber);
  v_41 = not(v_40);
  v_40 = (v_39 = 1.000000);
  v_39 =
    Utilities.compare_colors
    ((sens when St_TrafficLight(ck)).Globals.s_front, Globals.red);
  tp_St_Arrived = (tp_2 when St_Arrived(ck));
  lastActionTime_St_Arrived = (lastActionTime_1 when St_Arrived(ck));
  actionIndex_St_Arrived = (actionIndex_1 when St_Arrived(ck));
  arriving_St_Arrived = true;
  rspeed_St_Arrived = Globals.idlew;
  nr_St_Arrived = false;
  ns_St_Arrived = St_Arrived;
  rspeed =
    merge ck
      (St_Arrived -> rspeed_St_Arrived)
      (St_TrafficLight -> rspeed_St_TrafficLight)(St_Turn -> rspeed_St_Turn)
      (St_Obstacle -> rspeed_St_Obstacle)(St_Go -> rspeed_St_Go)
      (St_Action -> rspeed_St_Action);
  arriving =
    merge ck
      (St_Arrived -> arriving_St_Arrived)
      (St_TrafficLight -> arriving_St_TrafficLight)
      (St_Turn -> arriving_St_Turn)(St_Obstacle -> arriving_St_Obstacle)
      (St_Go -> arriving_St_Go)(St_Action -> arriving_St_Action);
  actionIndex =
    merge ck
      (St_Arrived -> actionIndex_St_Arrived)
      (St_TrafficLight -> actionIndex_St_TrafficLight)
      (St_Turn -> actionIndex_St_Turn)
      (St_Obstacle -> actionIndex_St_Obstacle)(St_Go -> actionIndex_St_Go)
      (St_Action -> actionIndex_St_Action);
  lastActionTime =
    merge ck
      (St_Arrived -> lastActionTime_St_Arrived)
      (St_TrafficLight -> lastActionTime_St_TrafficLight)
      (St_Turn -> lastActionTime_St_Turn)
      (St_Obstacle -> lastActionTime_St_Obstacle)
      (St_Go -> lastActionTime_St_Go)(St_Action -> lastActionTime_St_Action);
  tp =
    merge ck
      (St_Arrived -> tp_St_Arrived)(St_TrafficLight -> tp_St_TrafficLight)
      (St_Turn -> tp_St_Turn)(St_Obstacle -> tp_St_Obstacle)
      (St_Go -> tp_St_Go)(St_Action -> tp_St_Action);
  ns =
    merge ck
      (St_Arrived -> ns_St_Arrived)(St_TrafficLight -> ns_St_TrafficLight)
      (St_Turn -> ns_St_Turn)(St_Obstacle -> ns_St_Obstacle)
      (St_Go -> ns_St_Go)(St_Action -> ns_St_Action);
  nr =
    merge ck
      (St_Arrived -> nr_St_Arrived)(St_TrafficLight -> nr_St_TrafficLight)
      (St_Turn -> nr_St_Turn)(St_Obstacle -> nr_St_Obstacle)
      (St_Go -> nr_St_Go)(St_Action -> nr_St_Action);
  time = (Globals.timestep *. v_38);
  v_38 = Mathext.float(compt);
  compt = (v_36 + v_37);
  v_37 = 0 fby compt;
  v_36 = if true then 1 else 0
tel

