open Globals
open Utilities
open Mathext
type st = St_Turn|St_TrafficLight|St_Obstacle|St_Go|St_Arrived|St_Action
const obstacleDistance = 10
const dt = 0.016000
const cMAXSPEED_fix = 20.000000
node convertMsToDps(ms : float) returns (dps : float)
var v : float; v_1 : float; v_2 : float;
let
  dps = Mathext.floor(v_2);
  v_2 = (v_1 *. 6.000000);
  v_1 =
    ((60.000000 /. ((2.000000 *. Globals.pi) *. (Globals.cD /. 2.000000))) *.
     v);
  v = Utilities.min_float(ms, cMAXSPEED_fix)
tel

node getTurnTime(deg : float; ms : float) returns (time : float)
var arcLength : float; circumference : float; v : float; v_3 : float;
    v_4 : float;
let
  time = (v_4 -. Globals.timestep);
  v_4 = (arcLength /. ms);
  arcLength = (v_3 *. circumference);
  v_3 = (v /. 360.000000);
  v = Utilities.abs(deg);
  circumference = (Globals.pi *. Globals.cB)
tel

node calculateK(kc : float; pc : float)
returns (kp : float; ki : float; kd : float)
var v : float; v_5 : float; v_6 : float;
let
  kd = (v_6 /. (8.000000 *. dt));
  v_6 = (kp *. pc);
  ki = (v_5 /. pc);
  v_5 = (v *. dt);
  v = (2.000000 *. kp);
  kp = (0.600000 *. kc)
tel

node isActionMark(c : Globals.color) returns (res : bool)
var v : float;
let
  res = (v = 1.000000);
  v = Utilities.compare_colors(c, Globals.green)
tel

node isTrafficLightMark(c : Globals.color) returns (res : bool)
var v : float;
let
  res = (v = 1.000000);
  v = Utilities.compare_colors(c, Globals.red)
tel

node controller(sens : Globals.sensors; iti : Globals.itielts)
returns (rspeed : Globals.wheels; arriving : bool)
var actionIndex : int; actionIndex_1 : int; pnr : bool; nr : bool; r : bool;
    ns : st; ck : st; rspeed_St_Action : Globals.wheels;
    arriving_St_Action : bool; actionIndex_St_Action : int;
    ns_St_Action : st; nr_St_Action : bool; rspeed_St_Go : Globals.wheels;
    arriving_St_Go : bool; actionIndex_St_Go : int; ns_St_Go : st;
    nr_St_Go : bool; rspeed_St_Turn : Globals.wheels;
    arriving_St_Turn : bool; actionIndex_St_Turn : int; ns_St_Turn : st;
    nr_St_Turn : bool; rspeed_St_Obstacle : Globals.wheels;
    arriving_St_Obstacle : bool; actionIndex_St_Obstacle : int;
    ns_St_Obstacle : st; nr_St_Obstacle : bool;
    rspeed_St_TrafficLight : Globals.wheels; arriving_St_TrafficLight : bool;
    actionIndex_St_TrafficLight : int; ns_St_TrafficLight : st;
    nr_St_TrafficLight : bool; rspeed_St_Arrived : Globals.wheels;
    arriving_St_Arrived : bool; actionIndex_St_Arrived : int;
    ns_St_Arrived : st; nr_St_Arrived : bool; act : Globals.action;
    v_57 : bool; v_58 : bool; v_59 : bool; v_60 : st; v_61 : bool; v_62 : st;
    v_63 : bool; v_64 : Globals.itielt; derivative : float; integral : float;
    error : float; lastError : float; kd : float; ki : float; kp : float;
    turn : float; tp : float; outActionMark : bool; onActionMark : bool;
    isObstacle : bool; onTrafficLight : bool; onActionMark_1 : bool;
    outActionMark_1 : bool; error_1 : float; integral_1 : float;
    derivative_1 : float; v_30 : st; v_31 : bool; v_32 : st; v_33 : bool;
    v_34 : bool; v_35 : bool; v_36 : bool; v_37 : int; v_38 : float;
    v_39 : float; v_40 : float; v_41 : float; v_42 : float; v_43 : float;
    v_44 : Globals.itielt; v_45 : float; v_46 : float; v_47 : bool;
    v_48 : float; v_49 : bool; v_50 : float; v_51 : bool; v_52 : bool;
    v_53 : bool; v_54 : float; v_55 : float; v_56 : float; speed : float;
    turn_time : float; cpt : int; v_14 : Globals.itielt; v_15 : int;
    v_16 : Globals.itielt; v_17 : float; v_18 : bool; v_19 : int; v_20 : int;
    v_21 : float; v_22 : int; v_23 : Globals.itielt; v_24 : Globals.itielt;
    v_25 : bool; v_26 : float; v_27 : Globals.wheels; v_28 : float;
    v_29 : Globals.wheels; v_13 : bool; v : float; v_7 : bool; v_8 : bool;
    v_9 : float; v_10 : bool; v_11 : bool; v_12 : bool;
let
  actionIndex_1 = ~-(1) fby actionIndex;
  r = pnr;
  pnr = false fby nr;
  ck = St_Action fby ns;
  act = v_64.Globals.act;
  v_64 = (iti when St_Action(ck))[>(actionIndex when St_Action(ck))<];
  actionIndex_St_Action = ((actionIndex_1 when St_Action(ck)) + 1);
  arriving_St_Action = false;
  rspeed_St_Action = Globals.idlew;
  nr_St_Action = if v_57 then true else v_63;
  ns_St_Action = if v_57 then St_Turn else v_62;
  v_63 = if v_58 then true else v_61;
  v_62 = if v_58 then St_Go else v_60;
  v_61 = if v_59 then true else false;
  v_60 = if v_59 then St_Arrived else St_Action;
  v_59 = (act = Globals.Stop);
  v_58 = (act = Globals.Go);
  v_57 = (act = Globals.Turn);
  derivative_1 = if (r when St_Go(ck)) then 0.000000 else v_56;
  v_56 = 0.000000 fby derivative;
  integral_1 = if (r when St_Go(ck)) then 0.000000 else v_55;
  v_55 = 0.000000 fby integral;
  error_1 = if (r when St_Go(ck)) then 0.000000 else v_54;
  v_54 = 0.000000 fby error;
  outActionMark_1 = if (r when St_Go(ck)) then false else v_53;
  v_53 = false fby outActionMark;
  onActionMark_1 = if (r when St_Go(ck)) then false else v_52;
  v_52 = false fby onActionMark;
  actionIndex_St_Go = (actionIndex_1 when St_Go(ck));
  arriving_St_Go = false;
  isObstacle = ((sens when St_Go(ck)).Globals.s_sonar <= obstacleDistance);
  onTrafficLight = (v_49 or v_51);
  v_51 = (v_50 >=. 1.000000);
  v_50 =
    Utilities.compare_colors
    ((sens when St_Go(ck)).Globals.s_front, Globals.amber);
  v_49 = (v_48 >=. 1.000000);
  v_48 =
    Utilities.compare_colors
    ((sens when St_Go(ck)).Globals.s_front, Globals.red);
  outActionMark = (onActionMark_1 & v_47);
  v_47 = not(onActionMark);
  onActionMark = isActionMark((sens when St_Go(ck)).Globals.s_road);
  rspeed_St_Go = { Globals.left = v_45; Globals.right = v_46 };
  v_46 = (tp +. turn);
  v_45 = (tp -. turn);
  tp = convertMsToDps(v_44.Globals.param);
  v_44 = (iti when St_Go(ck))[>(actionIndex when St_Go(ck))<];
  turn = (v_42 +. v_43);
  v_43 = (kd *. derivative);
  v_42 = (v_40 +. v_41);
  v_41 = (ki *. integral);
  v_40 = (kp *. error);
  lastError = error_1;
  derivative = (error -. lastError);
  integral = (v_39 +. error);
  v_39 = ((2.000000 /. 3.000000) *. integral_1);
  error = if v_36 then error_1 else v_38;
  v_38 = Mathext.float(v_37);
  v_37 =
    ((sens when St_Go(ck)).Globals.s_road.Globals.red -
     (sens when St_Go(ck)).Globals.s_road.Globals.green);
  v_36 = (v_34 or v_35);
  v_35 = isTrafficLightMark((sens when St_Go(ck)).Globals.s_road);
  v_34 = isActionMark((sens when St_Go(ck)).Globals.s_road);
  (kp, ki, kd) = calculateK(0.700000, 2.350000);
  nr_St_Go = if outActionMark then true else v_33;
  ns_St_Go = if outActionMark then St_Action else v_32;
  v_33 = if onTrafficLight then true else v_31;
  v_32 = if onTrafficLight then St_TrafficLight else v_30;
  v_31 = if isObstacle then true else false;
  v_30 = if isObstacle then St_Obstacle else St_Go;
  actionIndex_St_Turn = (actionIndex_1 when St_Turn(ck));
  arriving_St_Turn = false;
  rspeed_St_Turn = if v_25 then v_27 else v_29;
  v_29 = { Globals.left = speed; Globals.right = v_28 };
  v_28 = ~-.(speed);
  v_27 = { Globals.left = v_26; Globals.right = speed };
  v_26 = ~-.(speed);
  v_25 = (v_24.Globals.param >. 0.000000);
  v_24 = (iti when St_Turn(ck))[>(actionIndex when St_Turn(ck))<];
  speed = convertMsToDps(v_23.Globals.param);
  v_23 = (iti when St_Turn(ck))[>v_22<];
  v_22 = ((actionIndex when St_Turn(ck)) - 1);
  turn_time = (Globals.timestep *. v_21);
  v_21 = Mathext.float(cpt);
  cpt = (1 + v_20);
  v_20 = if (r when St_Turn(ck)) then 0 else v_19;
  v_19 = 0 fby cpt;
  nr_St_Turn = if v_18 then true else false;
  ns_St_Turn = if v_18 then St_Action else St_Turn;
  v_18 = (v_17 <. turn_time);
  v_17 = getTurnTime(v_14.Globals.param, v_16.Globals.param);
  v_16 = (iti when St_Turn(ck))[>v_15<];
  v_15 = ((actionIndex when St_Turn(ck)) - 1);
  v_14 = (iti when St_Turn(ck))[>(actionIndex when St_Turn(ck))<];
  actionIndex_St_Obstacle = (actionIndex_1 when St_Obstacle(ck));
  arriving_St_Obstacle = false;
  rspeed_St_Obstacle = Globals.idlew;
  nr_St_Obstacle = if v_13 then true else false;
  ns_St_Obstacle = if v_13 then St_Go else St_Obstacle;
  v_13 = ((sens when St_Obstacle(ck)).Globals.s_sonar > obstacleDistance);
  actionIndex_St_TrafficLight = (actionIndex_1 when St_TrafficLight(ck));
  arriving_St_TrafficLight = false;
  rspeed_St_TrafficLight = Globals.idlew;
  nr_St_TrafficLight = if v_12 then true else false;
  ns_St_TrafficLight = if v_12 then St_Go else St_TrafficLight;
  v_12 = (v_8 & v_11);
  v_11 = not(v_10);
  v_10 = (v_9 = 1.000000);
  v_9 =
    Utilities.compare_colors
    ((sens when St_TrafficLight(ck)).Globals.s_front, Globals.amber);
  v_8 = not(v_7);
  v_7 = (v = 1.000000);
  v =
    Utilities.compare_colors
    ((sens when St_TrafficLight(ck)).Globals.s_front, Globals.red);
  actionIndex_St_Arrived = (actionIndex_1 when St_Arrived(ck));
  arriving_St_Arrived = true;
  rspeed_St_Arrived = Globals.idlew;
  nr_St_Arrived = false;
  ns_St_Arrived = St_Arrived;
  rspeed =
    merge ck
      (St_Arrived -> rspeed_St_Arrived)
      (St_TrafficLight -> rspeed_St_TrafficLight)
      (St_Obstacle -> rspeed_St_Obstacle)(St_Turn -> rspeed_St_Turn)
      (St_Go -> rspeed_St_Go)(St_Action -> rspeed_St_Action);
  arriving =
    merge ck
      (St_Arrived -> arriving_St_Arrived)
      (St_TrafficLight -> arriving_St_TrafficLight)
      (St_Obstacle -> arriving_St_Obstacle)(St_Turn -> arriving_St_Turn)
      (St_Go -> arriving_St_Go)(St_Action -> arriving_St_Action);
  actionIndex =
    merge ck
      (St_Arrived -> actionIndex_St_Arrived)
      (St_TrafficLight -> actionIndex_St_TrafficLight)
      (St_Obstacle -> actionIndex_St_Obstacle)
      (St_Turn -> actionIndex_St_Turn)(St_Go -> actionIndex_St_Go)
      (St_Action -> actionIndex_St_Action);
  ns =
    merge ck
      (St_Arrived -> ns_St_Arrived)(St_TrafficLight -> ns_St_TrafficLight)
      (St_Obstacle -> ns_St_Obstacle)(St_Turn -> ns_St_Turn)
      (St_Go -> ns_St_Go)(St_Action -> ns_St_Action);
  nr =
    merge ck
      (St_Arrived -> nr_St_Arrived)(St_TrafficLight -> nr_St_TrafficLight)
      (St_Obstacle -> nr_St_Obstacle)(St_Turn -> nr_St_Turn)
      (St_Go -> nr_St_Go)(St_Action -> nr_St_Action)
tel

