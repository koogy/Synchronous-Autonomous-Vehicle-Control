open Globals
open Utilities


const obstacleDistance : int = 70
const dt : float = 0.016 (* (16 ms/cycle) *)

fun convertMsToDps(ms : float) returns (dps : float)
let
  dps = (60.0 /. (2.0 *. pi *. (cD/. 2.0))) *. (ms) *. 6.0
tel

(* calculate the time required for the robot to turn a certain number of degrees at a certain speed *)
fun getTurnTime(deg, ms : float) returns (time : float)
var circumference : float;arcLength: float;
let
  circumference = pi *. cB ;
  arcLength = (abs(deg)/. 360.0) *. circumference; 
  time = (arcLength/.100.0) /.(ms/.100.0) ;
tel 

(*  Ziegler–Nichols method  *)
fun calculateK(kc,pc: float) returns (kp,ki,kd : float)
let
  kp = 0.6 *. kc;
  ki = (2.0 *. kp *. dt) /. pc;
  kd = (kp *. pc) /. (8.0 *. dt)
tel

fun isAction(c : color) returns ( res : bool)
let
   res = ((compare_colors(c,green)) = 1.0)
tel

node controller(sens : sensors; iti : itielts)
       returns (rspeed : wheels; arriving : bool)
var compt : int; time: float; last actionIndex: int = -1; last lastActionTime: float = 0.0;  last tp: float = 0.0;
let

  compt = (if true then 1 else 0) + (0 fby compt);
  time = timestep *. Mathext.float(compt);
  automaton
    state Action
      var act : action;
      do lastActionTime = time;
         rspeed= idlew;
         arriving = false;
         actionIndex =  (last actionIndex +1);
         act = ((iti[>actionIndex<]).act);
      until (act = Turn) then Turn
            | (act = Go) then Go
            | (act = Stop) then Arrived 
          
    state Go 
      var onActionMark,onTrafficLight,isObstacle: bool;
      turn,kp,ki,kd,lastError : float; 

      last error : float = 0.0;
      last integral : float = 0.0;
      last derivative : float = 0.0;
      do  
          (* ~2.35s : periode d'oscillation calculé grace a Trace*)
          (kp,ki,kd) = calculateK(0.7,2.35);

          (* -- Si c'est une action alors on reprend la dernière valeur 
          sinon ça fausse le calcul du PID puisqu'on detecte une couleur différente *)
          error = if isAction(sens.s_road) then last error
          else Mathext.float(sens.s_road.red - sens.s_road.green);
         
          integral = if isAction(sens.s_road) then last integral 
          else (2.0/.3.0)*.(last integral) +. error;

          derivative = if isAction(sens.s_road) then last derivative
          else error -. lastError;
          (* -- *)
          lastError = last error;

          turn = (kp *. error) +. (ki *. integral) +. (kd *. derivative);
          tp =  convertMsToDps((iti[>actionIndex<]).param);
          rspeed = { left = tp -. turn  ; right = tp +. turn };

          (* 0.5 sec doit s'écouler avant de pouvoir realiser une nouvelle action sinon on restera bloqué pour le turn*)
          onActionMark = (isAction(sens.s_road)) and ((time -. lastActionTime) >. 0.5);
          onTrafficLight = (compare_colors(sens.s_front, red) >=. 1.0) or (compare_colors(sens.s_front, amber) >=. 1.0);
          isObstacle = (sens.s_sonar <= obstacleDistance);
          arriving = false;

      until (onActionMark) then Action 
          | onTrafficLight then TrafficLight
          | isObstacle then Obstacle

    state Turn
      var cpt : int; turn_time,speed: float;
      do cpt = (if true then 1 else 0) + (0 fby cpt);
         turn_time = timestep *. Mathext.float(cpt);
         speed = convertMsToDps((iti[> actionIndex-1<]).param);
         (* if angle is positive... else .. *)
         rspeed = if (iti[> actionIndex<]).param >. 0.0 then  
         {left = -. speed; right = (speed)} else 
         {left = speed; right = -. (speed)};
         arriving = false;
      until (turn_time >. getTurnTime((iti[>(actionIndex)<]).param,(iti[> actionIndex -1<]).param)) then Action

    state Obstacle
      do rspeed= idlew;
         arriving = false;
      until (sens.s_sonar > obstacleDistance) then Go

    state TrafficLight
      do rspeed = idlew;
         arriving = false;
      until (compare_colors(sens.s_front, red) <> 1.0) and (compare_colors(sens.s_front, amber) <> 1.0) then Go

    state Arrived 
      do rspeed = idlew;
         arriving = true;
    end
tel
