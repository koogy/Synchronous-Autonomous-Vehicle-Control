open Globals
open Utilities

const ratioL : float = 0.5
const ratioR : float = 1.0 -. ratioL

fun convertMsToRpm(ms : float) returns (rpm : float)
let
  rpm = (60.0 /. (2.0 *. pi *. (cD/. 2.0))) *. (ms)
tel

fun convertRpmToDps(rpm : float) returns (dps : float)
let
  dps = rpm *. 6.0
tel

fun convertMsToDps(ms: float) returns (dps: float)
let 
  dps = convertRpmToDps(convertMsToRpm(ms))
tel


fun power2(value1 : int) returns (v : int)
let 
  v = value1*value1;
tel 

fun compare_colors(color1,color2 : color) returns (v : float)
let
  v = Mathext.sqrt(Mathext.float(power2(color1.red - color2.red)) +. Mathext.float(power2(color1.green - color2.green)) +. Mathext.float(power2(color1.blue - color2.blue)))
tel

fun getDistances(sens : sensors) returns ( left, mid, right: float)
var targetColor : color;
let
  targetColor = 
  {red = Mathext.int((Mathext.float(cyan.red) *. ratioL)  +. (Mathext.float(blue.red) *. ratioR)) ; 
  green = Mathext.int((Mathext.float(cyan.green) *. ratioL) +. (Mathext.float(blue.green) *. ratioR))  ; 
  blue = Mathext.int((Mathext.float(cyan.blue) *. ratioL) +. (Mathext.float(blue.blue) *. ratioR)) };
  
  left = compare_colors(sens.s_road, cyan) ;
  mid = compare_colors(sens.s_road, targetColor);
  right = compare_colors(sens.s_road, magenta)
tel

fun getDirection(left,mid,right, action, obs: float) returns ( direction : int)
var min :float;
let
  min = min_float(min_float(left,mid),min_float(action,right));
  direction = if (min = left) then 1
              else if (min = mid or min = action or min = obs) then 0
              else if (min = right ) then -1
              else 0;
tel 

fun setSpeed(turn,tp: float) returns (rspeed: wheels)
var left, right: float;
let
  left = max_float(min_float(tp +. turn, tp), -.tp) ;
  right = max_float(min_float(tp -. turn, tp), -.tp) ;
  rspeed = { left = left; right = right}
tel 

fun getTimeAngle(deg, ms : float) returns (time : float)
var circumference : float;arcLength: float;
let
  circumference = pi *. cB ;
  arcLength = (abs(deg)/. 360.0) *. circumference; 
  time = (arcLength/.100.0) /.(ms/.100.0) ;
tel 

fun d_pid(msg:string; left,mid,right, error,turn :float) returns ()
var w0,w1, w2, w3, w4, w5, w6 ,w7,w8,w9,w10,w11: Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);
  w1 = Debug.d_string(w0, "{ LEFT = ");
  w2 = Debug.d_float(w1, left);
  w3 = Debug.d_string(w2, "; MID = ");
  w4 = Debug.d_float(w3, mid);
  w5 = Debug.d_string(w4, "; RIGHT = ");
  w6 = Debug.d_float(w5, right);
  w7 = Debug.d_string(w6, " }\n{ ERRROR : " );
  w8 = Debug.d_float(w7, error);
  w9 = Debug.d_string(w8, "; TURN = ");
  w10 = Debug.d_float(w9, turn);
  w11 = Debug.d_string(w10, " }\n" );
tel

fun dbg_int(msg : string; v : int) returns ()
var w0, w1, w2: Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);
  w1 = Debug.d_int(w0,v);
  w2 = Debug.d_string(w1, "\n");
tel

fun dbg_bool(msg : string; v : bool) returns ()
var w0, w1, w2: Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);
  w1 = Debug.d_bool(w0,v);
  w2 = Debug.d_string(w1, "\n");
tel

fun dbg_float(msg : string; v : float) returns ()
var w0, w1, w2: Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);
  w1 = Debug.d_float(w0,v);
  w2 = Debug.d_string(w1, "\n");
tel

fun dbg_pid(msg : string; error,integral, derivative : float) returns ()
let
  () = dbg_float(msg,integral );
tel


fun calculateKp(kc : float) returns (kp : float)
let
  kp = 0.6 *. kc
tel

fun calculateKi(kp,dt,pc : float) returns ( ki : float)
let
  ki =(2.0 *. kp *. dt)/. pc
tel

fun calculateKd(kp,dt,pc : float) returns ( kd : float)
let
  kd = (kp *. 2.35) /. (8.0 *. dt)
tel


node controller(sens : sensors; iti : itielts)
       returns (rspeed : wheels; arriving : bool)
var compt : int; timez: float; last actionIndex: int = -1; last lastActionTime: float = 0.0;  last tp: float = 0.0;
let

  compt = (if true then 1 else 0) + (0 fby compt);
  timez = timestep *. Mathext.float(compt);
  automaton
    state Action
      var act : action;
      do lastActionTime = timez;
         rspeed= idlew;
         arriving = false;
         actionIndex =  (last actionIndex +1);
         act = ((iti[>actionIndex<]).act);
       (*   () = dbg_action("ACTION", act); *)
     
      until (act = Turn) then Turn
            | (act = Go) then Running
            | (act = Stop) then Arrived 
            

    state Running 
      var actionMark,tLight: bool;
      left,mid,right,
      turn: float; 
      last kp : float = 0.0;
      last ki : float = 0.0;
      last kd : float = 0.0;
      last error : float = 0.0;
      last lastError : float = 0.0;
      last integral : float = 0.0;
      last derivative : float = 0.0;
      last pc : float = 0.0;
      last dt : float = 0.0;
      do  
          dt = 0.016; (* 16 ms/cycle *)
          pc = 2.37; (* oscillation 2.37 sec *)
          
          kp = calculateKp(0.775);
          ki = calculateKi(kp,dt,pc) ;
          kd = calculateKd(kp,dt,pc);

          (left,mid,right) = (getDistances(sens));
          error =  mid *. Mathext.float(getDirection(left,mid,right, compare_colors(sens.s_road,green),compare_colors(sens.s_road,blue)));
          integral = (2.0/.3.0)*.(last integral) +. error;
   
          derivative = error -. lastError;
          lastError = last error;
          turn = (kp *. error) +. (ki *. integral) +. (kd *. derivative);

          tp =  if (((iti[>actionIndex<]).act)= Go) then  convertMsToDps((iti[>actionIndex<]).param) else last tp;
          rspeed = setSpeed(turn,tp);
          actionMark = if ((Utilities.compare_colors(sens.s_road, green) >=. 1.0) and ((timez -. lastActionTime) >. 0.5)) then true else false;
          tLight = if (Utilities.compare_colors(sens.s_front, red) >=. 1.0) then true else false;
          arriving = false;
          () = dbg_sensors("sensor", sens);

      until (actionMark) then Action 
          | tLight then TrafficLight

    state Turn
      var cpt : int; time,speed: float;
      do cpt = (if true then 1 else 0) + (0 fby cpt);
         time = timestep *. Mathext.float(cpt);
         speed = convertMsToDps((iti[> actionIndex -1<]).param);
         rspeed = if (((iti[> actionIndex<]).param) >. 0.0) then  
         {left = -. speed; right = (speed)} else 
         {left = speed; right = -. (speed)};
         arriving = false;
      until (time >. (getTimeAngle((iti[>(  actionIndex)<]).param,(iti[> actionIndex -1<]).param))) then Action

    state TrafficLight
      do rspeed = idlew;
         arriving = false;
      until (Utilities.compare_colors(sens.s_front, red) <. 1.0) then Running

    state Arrived 
      do rspeed = idlew;
         arriving = true;
    end
tel
