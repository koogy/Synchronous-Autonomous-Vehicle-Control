open Globals
open Utilities
(*cyan left
  blue middle
  magenta right 
 *)
const test : float = 0.5
const kp : float = 3.25
const ki : float = 0.0
const tp : float =  416.696578277

(*  *)

fun convertMsToRpm(ms : float) returns (rpm : float)
let
  rpm = (60.0 /. (2.0 *. pi *. cD/.100.0)) *. ms
tel

fun convertRpmToDps(rpm : float) returns (dps : float)
let
  dps = rpm *. 6.0
tel

(* PID *)
fun power2(value1 : int) returns (v : int)
let 
  v = value1*value1;
tel 

fun compare_colors(color1,color2 : color) returns (v : float)
let
  v = Mathext.sqrt(Mathext.float(power2(color1.red - color2.red)) +. Mathext.float(power2(color1.green - color2.green)) +. Mathext.float(power2(color1.blue - color2.blue)))
tel


fun getDistances(sens : sensors) returns ( left, middle, right: float)
var mid : color;
let

  mid = {red = Mathext.int((Mathext.float(cyan.red) *. test) +. (Mathext.float(blue.red) *. test)) ; green = Mathext.int((Mathext.float(cyan.green) *. test) +. (Mathext.float(blue.green) *. test))  ; blue = Mathext.int((Mathext.float(cyan.blue) *. test) +. (Mathext.float(blue.blue) *. test)) };
  left = compare_colors(sens.s_road, cyan) ;
  middle = compare_colors(sens.s_road, mid);
  right = compare_colors(sens.s_road, magenta)
tel

fun getDirection(left,middle,right: float) returns ( direction : int)
var min :float;
let
  
  min = min_float(min_float(left,middle),right);
  direction = if (min = left) then 1
              else if (min = middle) then 0
              else if (min = right) then -1
              else 0;
tel 

fun adjustSpeed(speed: float) returns (s:float)
let
  s= speed;
(*   s= speed; *)
tel 

fun setMotorSpeed(leftSpeed,rightSpeed : float ) returns (ls,rs : float)  

(* var 
w0,w1,w2,w3,w4,w5,w6 : Debug.world;  *)
let
(*  w0 = Debug.d_string(Debug.d_init(), "[setMotorSpeed] \n");
  w1 = Debug.d_int(w0, 0);
  w2 = Debug.d_string(w1, "\n");
  w3 = Debug.d_float(w2, leftSpeed);
  w4 = Debug.d_string(w3, "\n");
  w5 = Debug.d_float(w4, rightSpeed);
  w6 = Debug.d_string(w5, "\n");  *)
	  ls = adjustSpeed(leftSpeed) 
		rs = adjustSpeed(rightSpeed)


fun d_pid(msg:string; left,mid,right, error,turn :float) returns ()
var w0,w1, w2, w3, w4, w5, w6 ,w7,w8,w9,w10,w11: Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);
  w1 = Debug.d_string(w0, "{ LEFT = ");
  w2 = Debug.d_float(w1, left);
  w3 = Debug.d_string(w2, "; MID = ");
  w4 = Debug.d_float(w3, mid);
  w5 = Debug.d_string(w4, "; RIGHT = ");
  w6 = Debug.d_float(w5, right);
  w7 = Debug.d_string(w6, " }\n{ ERRROR : " );
  w8 = Debug.d_float(w7, error);
  w9 = Debug.d_string(w8, "; TURN = ");
  w10 = Debug.d_float(w9, turn);
  w11 = Debug.d_string(w10, " }\n" );
tel

fun dbg_direction(msg : string; direction : int) returns ()
var w0, w1, w2: Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);
  w1 = Debug.d_int(w0,direction);
  w2 = Debug.d_string(w1, " }\n ");
tel

node controller(sens : sensors; iti : itielts)
       returns (rspeed : wheels; arriving : bool)

var 
left,mid,right,leftSpeed,rightSpeed,error,turn,integral,testt: float;


let
  testt = -. 509.0;
  (left,mid,right) = (getDistances(sens));
  error =  mid *. Mathext.float(getDirection(left,mid,right));
  integral = (0.0 fby integral) +. error;
  turn = ((kp *. error) +. ki *. integral);
  (leftSpeed,rightSpeed) = setMotorSpeed(tp +. turn, tp -. turn);
  rspeed = { left = (leftSpeed); right = (rightSpeed) };
  arriving = false;

  () = dbg_color("Couleur \n",sens.s_road);
  () = dbg_wheels("WHEELS \n ", rspeed);
  () = dbg_direction("DIRECTION : ",Mathext.int(tp +. turn));
  () = dbg_direction("DIRECTION : ",Mathext.int(leftSpeed));
  () = d_pid("PID \n", left,mid,right,error,turn);

tel


(*   () = Trace.trace_int("Direction",getDirection(sens));
  () = Trace.trace_float("turn",turn);
  () = Trace.trace_float("error",error);
  () = Trace.trace_float("leftSpeed",leftSpeed);
  () = Trace.trace_float("rightSpeed",rightSpeed); *)